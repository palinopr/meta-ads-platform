-- Create API usage alerts table for monitoring system
CREATE TABLE IF NOT EXISTS api_usage_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_id TEXT NOT NULL UNIQUE,
    config_name TEXT NOT NULL,
    severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    message TEXT NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    account_id TEXT,
    metrics_snapshot JSONB,
    resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_api_usage_alerts_user_id ON api_usage_alerts(user_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_alerts_severity ON api_usage_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_api_usage_alerts_resolved ON api_usage_alerts(resolved);
CREATE INDEX IF NOT EXISTS idx_api_usage_alerts_created_at ON api_usage_alerts(created_at);

-- Enable RLS
ALTER TABLE api_usage_alerts ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own alerts" ON api_usage_alerts
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert alerts" ON api_usage_alerts
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Users can update their own alerts" ON api_usage_alerts
    FOR UPDATE USING (auth.uid() = user_id);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_api_usage_alerts_updated_at
    BEFORE UPDATE ON api_usage_alerts
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create API usage metrics table (for historical tracking)
CREATE TABLE IF NOT EXISTS api_usage_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    account_id TEXT,
    endpoint TEXT NOT NULL,
    http_method TEXT NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    request_points INTEGER NOT NULL DEFAULT 1,
    rate_limit_utilization REAL NOT NULL DEFAULT 0,
    error_code TEXT,
    error_message TEXT,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for metrics table
CREATE INDEX IF NOT EXISTS idx_api_usage_metrics_user_id ON api_usage_metrics(user_id);
CREATE INDEX IF NOT EXISTS idx_api_usage_metrics_created_at ON api_usage_metrics(created_at);
CREATE INDEX IF NOT EXISTS idx_api_usage_metrics_endpoint ON api_usage_metrics(endpoint);
CREATE INDEX IF NOT EXISTS idx_api_usage_metrics_status_code ON api_usage_metrics(status_code);

-- Enable RLS for metrics
ALTER TABLE api_usage_metrics ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for metrics
CREATE POLICY "Users can view their own metrics" ON api_usage_metrics
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert metrics" ON api_usage_metrics
    FOR INSERT WITH CHECK (true);

-- Create function to clean up old metrics (keep last 30 days)
CREATE OR REPLACE FUNCTION cleanup_old_metrics()
RETURNS void AS $$
BEGIN
    DELETE FROM api_usage_metrics 
    WHERE created_at < NOW() - INTERVAL '30 days';
    
    DELETE FROM api_usage_alerts 
    WHERE resolved = true AND resolved_at < NOW() - INTERVAL '7 days';
END;
$$ LANGUAGE plpgsql;

-- Create view for monitoring dashboard
CREATE OR REPLACE VIEW api_usage_dashboard AS
SELECT 
    u.id as user_id,
    u.email,
    COUNT(m.id) as total_requests,
    COUNT(CASE WHEN m.status_code >= 400 THEN 1 END) as error_requests,
    ROUND(AVG(m.response_time_ms), 2) as avg_response_time,
    MAX(m.rate_limit_utilization) as max_rate_limit_utilization,
    COUNT(CASE WHEN a.severity = 'critical' AND a.resolved = false THEN 1 END) as critical_alerts,
    COUNT(CASE WHEN a.severity = 'high' AND a.resolved = false THEN 1 END) as high_alerts,
    COUNT(CASE WHEN a.severity = 'medium' AND a.resolved = false THEN 1 END) as medium_alerts,
    MAX(m.created_at) as last_request_at
FROM auth.users u
LEFT JOIN api_usage_metrics m ON u.id = m.user_id AND m.created_at >= NOW() - INTERVAL '1 hour'
LEFT JOIN api_usage_alerts a ON u.id = a.user_id AND a.resolved = false
GROUP BY u.id, u.email
HAVING COUNT(m.id) > 0 OR COUNT(a.id) > 0;

-- Grant permissions for the service role to access these tables
GRANT ALL ON api_usage_alerts TO service_role;
GRANT ALL ON api_usage_metrics TO service_role;
GRANT SELECT ON api_usage_dashboard TO service_role;

-- Comment on tables
COMMENT ON TABLE api_usage_alerts IS 'Stores alerts generated by the API usage monitoring system';
COMMENT ON TABLE api_usage_metrics IS 'Stores detailed metrics for all API usage';
COMMENT ON VIEW api_usage_dashboard IS 'Provides aggregated view of API usage and alerts for monitoring dashboard';